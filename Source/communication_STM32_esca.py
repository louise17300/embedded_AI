# -*- coding: utf-8 -*-
"""
Created on Mon Feb 22 16:46:13 2021

@author: RJ264980
"""

import sys, os, array, time
import numpy as np
import serial, math, secrets
from random import *
from ast import literal_eval
import struct
from time import sleep

from sklearn import datasets
import tensorflow as tf
from tensorflow import keras

from matplotlib import pyplot as plt

img_width, img_height = 80, 45

class timer:
    def __init__(self, name=None):
        self.name = name

    def tic(self):
        self.T_start = time.time()

    def toc(self):
        self.T_stop = time.time()
        print("Elapsed time: " + str(self.T_stop - self.T_start) + " s")

def perso_model_prediction(model, input_values, summary=False):
    # Load an already existing model and test its outputs
    to_be_tested_model = tf.keras.models.load_model(model)

    if summary == True:
        to_be_tested_model.summary()
        for layers in to_be_tested_model.layers:
            print(layers.kernel)

    output_pred = to_be_tested_model.predict(input_values)
    return output_pred


class esca_set:
    def __init__(self, used_model):
        self.used_model = used_model

        self.x_sample = -1
        self.y_sample = -1

        self.received_output = np.zeros((1,10))
        #self.received_categories = np.zeros((3))

    def set_dataset_from_xtest(self, path_xtest, path_ytest):
        self.X_test = np.load(path_xtest).astype(dtype=np.float32)
        self.Y_test = np.load(path_ytest).astype(dtype=np.float32)

    def pick_rand_value_from_xtest(self):
        rand_sample = randint(0, self.X_test.shape[0]-1)
        self.x_sample = self.X_test[rand_sample]
        self.y_sample = self.Y_test[rand_sample]
        tmp = self.y_sample.argmax(axis=0)
        print("Chosen input's corresponding label is "+str(tmp)+" according to y_test")

    def get_prediction(self):
        print(self.x_sample.shape)
        tmp_proba = perso_model_prediction(self.used_model, self.x_sample)
        self.y_proba = tmp_proba
        tmp = self.y_proba.argmax(axis=0)
        print("\nPYTHON:")
        print("Model prediction is "+str(tmp)+" with probability "+str(self.y_proba[tmp]))
        
    def categorize_received_output(self):
        print ("STM32:")
        print ("Obtained probabilities: \n" + str(self.received_output.round(decimals=4)))
        index = self.received_output.argmax(axis=1)
        print ("Model prediction is "+str(index)+" with probability "+str(self.received_output[0][index])+"\n")

        if (self.y_sample.argmax(axis=0) != index):
            print ("***** Prediction does not match with y_test label")
        else:
            print ("***** Prediction matches with y_test label")

    def match_pred_label(self):
        if (self.y_sample.argmax(axis=0) != self.received_output.argmax(axis=1)):
            return 1
        else:
            return 0



def synchronisation_with_target(debug=True):
    """
    Vérifie la connexion avec la carte.

    Parameters
    ----------
    debug : TYPE, optional
        DESCRIPTION. The default is True.

    Returns
    -------
    None.

    """
    sync = False
    ret = ret1 = None
    ser.flush()
    while (sync == False):
        ser.write(b"s")
        #sleep(0.2)
        ret = ser.read(4)
        print(ret)
        if (ret == b"1010"): # "101" has been chosen arbitrarily
            sync = True
            if (debug):
                print("Synchronised")
        else:
            print(ser.read(1))
            if (debug):
                print ("Wrong ack reponse")
    ser.flush()

def send_NN_inputs_to_STM32(esca_set, ser):
    if not ser.isOpen():  # On vérifie si la liaison est bien ouverte
        print ("Error: serial connection to be used isn't opened")
        sys.exit(-1)

    # Synchronisation loop
    synchronisation_with_target()

    # Send inputs to the Neural Network
    input_sent = False
    ser.flush()
 
    #tmp = esca_set.x_sample.reshape(img_width,img_height) #depend du model utilise
    tmp = esca_set.x_sample
    print(tmp[0,0]/255)
    print(tmp.shape, " size elem : ", sys.getsizeof(tmp[0,0]))
    while(input_sent == False):

        for i in range(img_width):
            for j in range(img_height):
                ser.write(tmp[i,j]/255)  # Le modèle a été entrainé avec les valeurs divisées par 
                #print("i ", i, "j ", j, ":", tmp[i,j])
        print("Picture sent")
        input_sent = True

    # Used for debug (i.e. get the picture sent)
    # for i in range(80):
    #     for j in range(45):
    #         tmp[i][j] = struct.unpack('f', ser.read(4))[0]
    #plt.imshow(tmp, cmap='gray')
    #plt.show()

    # wait for the output values generated by the STM32
    out_ack = b"000"
    while(out_ack != b"111"): # "111" has been chosen arbitrarily
        out_ack = ser.read(3)
        print(out_ack)
    print("pass")
    for i in range(10):
        esca_set.received_output[0][i] = struct.unpack('f', ser.read(4))[0]

    esca_set.categorize_received_output()



if __name__ == '__main__':

    tf.autograph.set_verbosity(0)
    nb_inference = 10
    with serial.Serial("COM7", 115200, timeout=1) as ser: # COM5 for H743 (nucleo) and COM6 for F411 (Nucleo)
        chrono = timer("Chrono")
    
        # Model available for board's results comparaison
        used_model = "../Models/model_small_b32.h5"
    
        # X_test and Y_test dataset available for inference
        path_xtest = "../Models/validation_set/validation_x_set.npy"
        path_ytest = "../Models/validation_set/validation_y_set.npy"
        
    
        i = 0
        nb_error = 0
        errored_elem = []
    
        chrono.tic()
        while(i < nb_inference):
            print ("\n\n----------- Inference "+str(i)+" requested: -----------\n")
    
            t1 = esca_set(used_model)  # On crée une instance de notre classe esca_set
            t1.set_dataset_from_xtest(path_xtest, path_ytest)  # On récupère nos données de test et leur labels et on les stocke dans la classe
            t1.pick_rand_value_from_xtest()  # On prend un échantillon de donné
    
            print ("\n")
    
            send_NN_inputs_to_STM32(t1, ser)  # Envoie de l'image à notre STM
    
            if(t1.match_pred_label() == 1):
                nb_error += 1
                errored_elem.append(t1)
    
            i = i + 1
    
            del t1
    
        print ('\n')
        chrono.toc()
        print ("\nAll inferences have been effected")
        print ("\nNumber of error reported according to y_test: "+str(nb_error))
        ser.close()
